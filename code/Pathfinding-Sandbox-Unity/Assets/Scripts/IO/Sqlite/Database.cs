/* 
 * The MIT License (MIT)
 * 
 * Copyright (c) 2016-2021 Steve Sedlmayr and Droidknot LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
**/

using dk.Tools.Debug;

using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using System.Text;

using UnityEngine;
using UnityEngine.Networking;

namespace dk.IO.Sqlite {
    /// <summary>
    /// Pass-through class exposing and wrapping the sqlite3 library for perations with a local SQLite database.
    /// Based originally on code from this github repository: https://github.com/Busta117/SQLiteUnityKit.
    /// Per the wishes of the original authors, please do not use this code to create for-profit Unity Asset 
    /// Store products. All other commerical software products (games, applications, et cetera) are permissible 
    /// under the MIT license at the beginning of this file.
    /// 
    /// In this refactored version, methods are organized into formatted and unformatted query methods. The 
    /// Unformatted methods are essentially the legacy code; they attempt to execute whatever string the user 
    /// inputs as a SQLite query. It is up to the developer to make sure the query is valid. The new, formatted 
    /// methods handle some validation internally, delegating it to a set of methods that generate and validate 
    /// various kinds of common SQL statements. This should make usage much more convenient for most of the 
    /// day-to-day query requirements that would be common in a typical application. The reason that the generation 
    /// of statements is delegated to a seperate group of methods is because some queries have nested sub-queries; 
    /// statements within statements. The new structure allows the usage of this interface to match the modularity 
    /// of SQL statements themselves, as some of these methods take statments generated by a separate method. 
    /// 
    /// For any queries not covered by the formatted methods, the unformatted methods are still available.
    /// 
    /// Contact and authorship information for the original developers:
    /// 
    /// developed by Poya  @  http://gamesforsoul.com/
    /// BLOB support by Jonathan Derrough @ http://jderrough.blogspot.com/
    /// Modify and structure by Santiago Bustamante @ busta117@gmail.com
    /// Android compatibility by Thomas Olsen @ olsen.thomas@gmail.com
    /// </summary>
    [ToDo("Finish query convenience methods.", true, int.MinValue)]
    [ToDo("Test query convenience methods.", true, int.MinValue)]
    [ToDo("Create unit tests/editor fixture for testing.", true, int.MinValue)]
    [ToDo("Implement VALUES clause for SELECT", true, int.MinValue)]
    [ToDo("Finish XML docs documenation", true, int.MinValue)]
    public class Database {
        #region Status codes

        private const int SQLITE_OK = 0;
        private const int SQLITE_ROW = 100;
        private const int SQLITE_DONE = 101;
        private const int SQLITE_INTEGER = 1;
        private const int SQLITE_FLOAT = 2;
        private const int SQLITE_TEXT = 3;
        private const int SQLITE_BLOB = 4;
        private const int SQLITE_NULL = 5;
        //Busta117

        #endregion

        #region sqlite3 plugin method defines

        [DllImport("sqlite3", EntryPoint = "sqlite3_open")]
        private static extern int SqliteOpen(string filename, out IntPtr db);

        [DllImport("sqlite3", EntryPoint = "sqlite3_close")]
        private static extern int SqliteClose(IntPtr db);

        [DllImport("sqlite3", EntryPoint = "sqlite3_prepare_v2")]
        private static extern int SqlitePrepareV2(IntPtr db, string zSql, int nByte, out IntPtr ppStmpt, IntPtr pzTail);

        [DllImport("sqlite3", EntryPoint = "sqlite3_step")]
        private static extern int SqliteStep(IntPtr stmHandle);

        [DllImport("sqlite3", EntryPoint = "sqlite3_finalize")]
        private static extern int SqliteFinalize(IntPtr stmHandle);

        [DllImport("sqlite3", EntryPoint = "sqlite3_errmsg")]
        private static extern IntPtr SqliteErrorMessage(IntPtr db);

        [DllImport("sqlite3", EntryPoint = "sqlite3_column_count")]
        private static extern int SqliteColumnCount(IntPtr stmHandle);

        [DllImport("sqlite3", EntryPoint = "sqlite3_column_name")]
        private static extern IntPtr SqliteColumnName(IntPtr stmHandle, int iCol);

        [DllImport("sqlite3", EntryPoint = "sqlite3_column_type")]
        private static extern int SqliteColumnType(IntPtr stmHandle, int iCol);

        [DllImport("sqlite3", EntryPoint = "sqlite3_column_int")]
        private static extern int SqliteColumnInt(IntPtr stmHandle, int iCol);

        [DllImport("sqlite3", EntryPoint = "sqlite3_column_text")]
        private static extern IntPtr SqliteColumnText(IntPtr stmHandle, int iCol);

        [DllImport("sqlite3", EntryPoint = "sqlite3_column_double")]
        private static extern double SqliteColumnDouble(IntPtr stmHandle, int iCol);

        [DllImport("sqlite3", EntryPoint = "sqlite3_column_blob")]
        private static extern IntPtr SqliteColumnBlob(IntPtr stmHandle, int iCol);

        [DllImport("sqlite3", EntryPoint = "sqlite3_column_bytes")]
        private static extern int SqliteColumnBytes(IntPtr stmHandle, int iCol);
        //Busta117

        #endregion

        private bool _canExecuteQuery = true;
        private IntPtr _connection;
        private CoroutineCaller _cc = null;
        private GameObject _go = null;
        private bool _isConnectionOpen { get; set; }
        private string _databasePath;
        //ssedlmayr

        public enum InsertOrUpdateOption {
            NONE, 
            REPLACE, 
            ROLLBACK, 
            ABORT, 
            FAIL, 
            IGNORE
        }
        //ssedlmayr

        public enum OrderByPrecedence {
            NONE, 
            ASC, 
            DESC
        }
        //ssedlmayr

        /// <summary>
        /// Initializes a new instance of the <see cref="dk.IO.Sqlite.Database"/> class.
        /// </summary>
        /// <param name='dbName'> 
        /// The name of the database file. The file needs exist in the StreamingAssets folder.
        /// Originally written by Busta117; refactored by ssedlmayr to remove the deprecated WWW construction.
        /// </param>
        /// <param name='overwrite'></param>
        public Database(string dbName, bool overwrite=false) {
            _databasePath = System.IO.Path.Combine(Application.persistentDataPath, dbName);

            _go = new GameObject("CoroutineCallerParent");
            _cc = _go.AddComponent<CoroutineCaller>();
            _cc.StopAllCoroutines();
            _cc.StartCoroutine(LoadDB(dbName, overwrite));
        }
        //Busta117 -> ssedlmayr (re-wrote)

        /// <summary>
        /// 
        /// </summary>
        /// <param name="dbName"></param>
        /// <param name="overwrite"></param>
        /// <returns></returns>
        private IEnumerator LoadDB(string dbName, bool overwrite= false) {
            string sourcePath = System.IO.Path.Combine(Application.streamingAssetsPath, dbName);

            // If the DB does not exist in the persistentData folder or the source DB is newer, then copy it.
            if (!System.IO.File.Exists(_databasePath) || 
                (System.IO.File.GetLastWriteTimeUtc(sourcePath) > System.IO.File.GetLastWriteTimeUtc(_databasePath)) ||
                overwrite
            ) {
                if (Directives.majorRuntimeOS == Directives.MajorOS.ANDROID) {
                    UnityWebRequest www = UnityWebRequest.Get("file:///" + sourcePath);

                    // Wait for download to complete - not pretty at all but easy hack for now 
                    // and it would not take long since the data is on the local device. -busta117
                    yield return www.SendWebRequest();

                    if (www.result == UnityWebRequest.Result.Success) {
                        System.IO.File.WriteAllBytes(_databasePath, www.downloadHandler.data);

                        www.Dispose();
                        GameObject.DestroyImmediate(_cc);
                        GameObject.DestroyImmediate(_go);
                    } else {
                        _canExecuteQuery = false;
                    }
                } else {
                    if (System.IO.File.Exists(sourcePath)) {
                        System.IO.File.Copy(sourcePath, _databasePath, true);
                    } else {
                        _canExecuteQuery = false;
                        DebugLogger.LogError("The file DB named " + dbName + " doesn't exist in the StreamingAssets Folder, please copy it there.");
                    }
                }
            }
        }
        //ssedlmayr

        #region Formatted query convenience methods

        /// <summary>
        /// Method for querying the database with a SQL CREATE TABLE statement.
        /// </summary>
        /// <param name="name"></param>
        /// <param name="columns"></param>
        /// <param name="types"></param>
        /// <param name="hasPrimaryKey"></param>
        public void CreateTable(string name, string[] columns, string[] types, bool hasPrimaryKey=false) {
            int hasPrimaryKeyInt = (hasPrimaryKey) ? 0 : -1;
            CreateTable(name, columns, types, hasPrimaryKeyInt);
        }
        //ssedlmayr

        /// <summary>
        /// Method for querying the database with a SQL CREATE TABLE statement.
        /// </summary>
        /// <param name="table"></param>
        /// <param name="types"></param>
        /// <param name="hasPrimaryKey"></param>
        public void CreateTable(Table table, string[] types, bool hasPrimaryKey=false) {
            int hasPrimaryKeyInt = (hasPrimaryKey) ? 0 : -1;
            CreateTable(table, types, hasPrimaryKeyInt);
        }
        //ssedlmayr

        /// <summary>
        /// Method for querying the database with a SQL CREATE TABLE statement.
        /// </summary>
        /// <param name="name"></param>
        /// <param name="columns"></param>
        /// <param name="types"></param>
        /// <param name="primaryKeyIndex"></param>
        public void CreateTable(string name, string[] columns, string[] types, int primaryKeyIndex) {
            CreateTable(name, columns, types, "", false, primaryKeyIndex);
        }
        //ssedlmayr

        /// <summary>
        /// Method for querying the database with a SQL CREATE TABLE statement.
        /// </summary>
        /// <param name="table"></param>
        /// <param name="types"></param>
        /// <param name="primaryKeyIndex"></param>
        public void CreateTable(Table table, string[] types, int primaryKeyIndex) {
            CreateTable(table, types, "", false, primaryKeyIndex);
        }
        //ssedlmayr

        /// <summary>
        /// Method for querying the database with a SQL CREATE TABLE statement.
        /// </summary>
        /// <param name="name"></param>
        /// <param name="columns"></param>
        /// <param name="types"></param>
        /// <param name="schemaName"></param>
        /// <param name="isTemporary"></param>
        /// <param name="primaryKeyIndex"></param>
        /// <param name="withoutRowID"></param>
        /// <param name="fromTable"></param>
        /// <param name="withCondition"></param>
        public void CreateTable(string name, string[] columns, string[] types, string schemaName="", bool isTemporary=false, 
            int primaryKeyIndex=-1, bool withoutRowID=false, string fromTable="", string withCondition="") {
            Table table = new Table();
            table.name = name;
            table.Columns = new List<string>(columns);

            CreateTable(table, types, schemaName, isTemporary, primaryKeyIndex, withoutRowID, fromTable, withCondition);
        }
        //ssedlmayr

        /// <summary>
        /// Method for querying the database with a SQL CREATE TABLE statement.
        /// </summary>
        /// <param name="table"></param>
        /// <param name="types"></param>
        /// <param name="schemaName"></param>
        /// <param name="isTemporary"></param>
        /// <param name="primaryKeyIndex"></param>
        /// <param name="withoutRowID"></param>
        /// <param name="fromTable"></param>
        /// <param name="withCondition"></param>
        public void CreateTable(Table table, string[] types, string schemaName="", bool isTemporary=false, int primaryKeyIndex=-1, 
            bool withoutRowID=false, string fromTable="", string withCondition="") {
            string query = GenerateCreateTableStatement(table, types, schemaName, isTemporary, primaryKeyIndex, withoutRowID, fromTable, withCondition);
            Query(query);
        }
        //ssedlmayr

        /// <summary>
        /// Method for querying the database with a SQL DELETE statement.
        /// </summary>
        /// <param name="table"></param>
        /// <param name="whereCondition"></param>
        /// <param name="orderByClause"></param>
        /// <param name="limitClause"></param>
        /// <param name="withClause"></param>
        public void Delete(string table, string whereCondition="", string orderByClause="", string limitClause="", string withClause="") {
            string query = GenerateDeleteStatement(table, whereCondition, orderByClause, limitClause, withClause);
            Query(query);
        }
        //ssedlmayr

        /// <summary>
        /// Method for querying the database with a SQL DROP TABLE statement.
        /// </summary>
        /// <param name="table"></param>
        /// <param name="schemaName"></param>
        public void DropTable(string table, string schemaName="") {
            string query = GenerateDropTableStatement(table, schemaName);
            Query(query);
        }
        //ssedlmayr

        /// <summary>
        /// Method for querying the database with a SQL INSERT statement.
        /// </summary>
        /// <param name="table"></param>
        /// <param name="insertOption"></param>
        /// <param name="schemaName"></param>
        /// <param name="withClause"></param>
        public void Insert(string table, InsertOrUpdateOption insertOption=InsertOrUpdateOption.NONE, string schemaName="", string withClause="") {
            Insert(table, null, null, insertOption, schemaName, "", withClause);
        }
        //ssedlmayr

        /// <summary>
        /// Method for querying the database with a SQL INSERT statement.
        /// </summary>
        /// <param name="table"></param>
        /// <param name="selectStatement"></param>
        /// <param name="insertOption"></param>
        /// <param name="schemaName"></param>
        /// <param name="withClause"></param>
        public void Insert(string table, string selectStatement, InsertOrUpdateOption insertOption=InsertOrUpdateOption.NONE, 
            string schemaName="", string withClause="") {
            Insert(table, null, null, insertOption, schemaName, selectStatement, withClause);
        }
        //ssedlmayr

        /// <summary>
        /// Method for querying the database with a SQL INSERT statement.
        /// </summary>
        /// <param name="table"></param>
        /// <param name="values"></param>
        /// <param name="columns"></param>
        /// <param name="insertOption"></param>
        /// <param name="schemaName"></param>
        /// <param name="withClause"></param>
        public void Insert(string table, string[] values=null, string[] columns=null, 
            InsertOrUpdateOption insertOption=InsertOrUpdateOption.NONE, string schemaName="", string withClause="") {
            Insert(table, columns, values, insertOption, schemaName, "", withClause);
        }
        //ssedlmayr

        /// <summary>
        /// Method for querying the database with a SQL INSERT statement.
        /// </summary>
        /// <param name="table"></param>
        /// <param name="columns"></param>
        /// <param name="values"></param>
        /// <param name="insertOption"></param>
        /// <param name="schemaName"></param>
        /// <param name="selectStatement"></param>
        /// <param name="withClause"></param>
        public void Insert(string table, string[] columns=null, string[] values=null, 
            InsertOrUpdateOption insertOption=InsertOrUpdateOption.NONE, string schemaName="", string selectStatement="", string withClause="") {
            string query = GenerateInsertStatement(table, columns, values, insertOption, schemaName, selectStatement, withClause);
            Query(query);
        }
        //ssedlmayr

        /// <summary>
        /// Method for querying the database with a SQL SELECT statement.
        /// </summary>
        /// <param name="resultColumns"></param>
        /// <param name="tables"></param>
        /// <param name="groupByColumns"></param>
        /// <param name="havingExpression"></param>
        /// <param name="orderByClause"></param>
        /// <param name="limitClause"></param>
        /// <param name="isDistinct"></param>
        /// <param name="whereClause"></param>
        /// <param name="withClause"></param>
        /// <returns></returns>
        public Table Select(string[] resultColumns=null, string[] tables=null,
            string[] groupByColumns=null, string havingExpression="", string orderByClause="", string limitClause="", 
            bool isDistinct=false, string whereClause="", string withClause="") {
            string query = GenerateSelectStatement(resultColumns, tables, groupByColumns, havingExpression, 
                orderByClause, limitClause, isDistinct, whereClause, withClause);
            
            return QueryWithResponse(query);
        }
        //ssedlmayr

        /// <summary>
        /// Method for querying the database with a compound SQL SELECT statement.
        /// </summary>
        /// <param name="selectStatements"></param>
        /// <param name="withClause"></param>
        /// <returns></returns>
        public Table CompoundSelect(string[] selectStatements, string withClause="") {
            string query = GenerateCompoundSelectStatement(selectStatements, withClause);
            return QueryWithResponse(query);
        }
        //ssedlmayr

        /// <summary>
        /// Method for querying the database with a SQL UPDATE statement.
        /// </summary>
        /// <param name="table"></param>
        /// <param name="setValues"></param>
        public void Update(string table, KeyValuePair<string, string>[] setValues) {
            Update(table, setValues, "", InsertOrUpdateOption.NONE);
        }
        //ssedlmayr

        /// <summary>
        /// Method for querying the database with a SQL UPDATE statement.
        /// </summary>
        /// <param name="table"></param>
        /// <param name="setValues"></param>
        /// <param name="schemaName"></param>
        public void Update(string table, KeyValuePair<string, string>[] setValues, string schemaName) {
            Update(table, setValues, schemaName, InsertOrUpdateOption.NONE);
        }
        //ssedlmayr

        /// <summary>
        /// Method for querying the database with a SQL UPDATE statement.
        /// </summary>
        /// <param name="table"></param>
        /// <param name="setValues"></param>
        /// <param name="updateOption"></param>
        /// <param name="schemaName"></param>
        public void Update(string table, KeyValuePair<string, string>[] setValues, InsertOrUpdateOption updateOption, string schemaName="") {
            Update(table, setValues, schemaName, updateOption);
        }
        //ssedlmayr

        /// <summary>
        /// Method for querying the database with a SQL UPDATE statement.
        /// </summary>
        /// <param name="table"></param>
        /// <param name="schemaName"></param>
        /// <param name="updateOption"></param>
        /// <param name="setValues"></param>
        /// <param name="orderByClause"></param>
        /// <param name="limitClause"></param>
        /// <param name="whereClause"></param>
        /// <param name="withClause"></param>
        public void Update(string table, KeyValuePair<string, string>[] setValues, string schemaName="", 
            InsertOrUpdateOption updateOption=InsertOrUpdateOption.NONE, string orderByClause="", string limitClause="", string whereClause="", string withClause="") {
            string query = GenerateUpdateStatement(table, setValues, schemaName, updateOption, orderByClause, limitClause, whereClause, withClause);
            Query(query);
        }
        //ssedlmayr

        #endregion

        #region Statement generation methods

        /// <summary>
        /// Generates a properly formatted SQL CREATE TABLE statement from parameters.
        /// </summary>
        /// <param name="table"></param>
        /// <param name="types"></param>
        /// <param name="schemaName"></param>
        /// <param name="isTemporary"></param>
        /// <param name="primaryKeyIndex"></param>
        /// <param name="withoutRowID"></param>
        /// <param name="fromTable"></param>
        /// <param name="withCondition"></param>
        /// <returns></returns>
        public string GenerateCreateTableStatement(Table table, string[] types, string schemaName="", bool isTemporary=false, 
            int primaryKeyIndex=-1, bool withoutRowID=false, string fromTable="", string withCondition="") {
            if (table.Columns == null || table.Columns.Count == 0) {
                DebugLogger.LogError("The table contains no data.");
                return default(string);
            }

            if (types.Length != table.Columns.Count) {
                DebugLogger.LogError("The number of types is not equal to the number of columns.");
                return default(string);
            }

            if (withoutRowID && 
                (primaryKeyIndex <= -1 || primaryKeyIndex > table.Columns.Count - 1)
            ) {
                DebugLogger.LogError("Table is WITHOUT ROWID but an invalid primary key index was specified.");
                return default(string);
            }

            if (!string.IsNullOrEmpty(schemaName) && isTemporary) {
                DebugLogger.LogError("A table cannot be temporary and have a schema defined.");
                return default(string);
            }

            StringBuilder builder = new StringBuilder();
            builder.Append("CREATE ");
            if (isTemporary) builder.Append("TEMP "); // Handle temporary table, if specified
            builder.Append("TABLE IF NOT EXISTS ");
            if (!string.IsNullOrEmpty(schemaName)) builder.Append(schemaName + ".");
            builder.Append(table.name);

            // Append any AS SELECT statements
            if (!string.IsNullOrEmpty(fromTable) &&
                !string.IsNullOrEmpty(withCondition)) {
                builder.Append(" AS SELECT ");
                builder.Append(withCondition);
                builder.Append(" FROM ");
                builder.Append(fromTable);
                builder.Append(" ");
            }

            // Begin column definitons
            builder.Append("(");

            for (int i = 0; i < table.Columns.Count; i++) {
                builder.Append(table.Columns[i]);
                builder.Append("        ");
                builder.Append(types[i]);

                // Append PRIMARY KEY constraint, if specified
                if (primaryKeyIndex > -1 && 
                    i == primaryKeyIndex
                ) {
                    builder.Append("        ");
                    builder.Append("PRIMARY KEY");
                }

                // Append NOT NULL constraints (not required for WITHOUT ROWID)
                if (!withoutRowID) {
                    builder.Append("        ");
                    builder.Append("NOT NULL");
                }

                if (i <= table.Columns.Count - 2) builder.Append(",");
            }

            // Append WITHOUT ROWID constraint, if specified
            if (!withoutRowID) {
                builder.Append(");");
            } else {
                builder.Append(") WITHOUT ROWID;");
            }

            string query = builder.ToString();

            return query;
        }
        //ssedlmayr

        /// <summary>
        /// Generates a properly formatted SQL DELETE statement from parameters.
        /// </summary>
        /// <param name="table"></param>
        /// <param name="whereCondition"></param>
        /// <param name="orderByClause"></param>
        /// <param name="limitClause"></param>
        /// <param name="withClause"></param>
        /// <returns></returns>
        public string GenerateDeleteStatement(string table, string whereCondition="", string orderByClause="", string limitClause="", string withClause="") {
            StringBuilder builder = new StringBuilder();

            // Optional WITH statement
            if (!string.IsNullOrEmpty(withClause)) {
                builder.Append(withClause);
                builder.Append(" ");
            }

            builder.Append("DELETE FROM ");
            builder.Append(table);

            if (!string.IsNullOrEmpty(whereCondition)) {
                builder.Append(" WHERE ");
                builder.Append(whereCondition);
            }

            // Optional ORDER BY clause
            if (!string.IsNullOrEmpty(orderByClause)) {
                builder.Append(" ");
                builder.Append(orderByClause);
            }

            // Optional LIMIT, OFFSET clause
            if (!string.IsNullOrEmpty(limitClause)) {
                builder.Append(" ");
                builder.Append(limitClause);
            }

            string query = builder.ToString();

            return query;
        }
        //ssedlmayr

        /// <summary>
        /// Generates a properly formatted SQL DROP TABLE statement from parameters.
        /// </summary>
        /// <param name="table"></param>
        /// <param name="schemaName"></param>
        /// <returns></returns>
        public string GenerateDropTableStatement(string table, string schemaName="") {
            StringBuilder builder = new StringBuilder();
            builder.Append("DROP TABLE IF EXISTS ");
            if (!string.IsNullOrEmpty(schemaName)) builder.Append(schemaName + ".");
            builder.Append(table);

            string query = builder.ToString();

            return query;
        }
        //ssedlmayr

        /// <summary>
        /// Generates a properly formatted SQL INSERT statement from parameters.
        /// </summary>
        /// <param name="table"></param>
        /// <param name="columns"></param>
        /// <param name="values"></param>
        /// <param name="insertOption"></param>
        /// <param name="schemaName"></param>
        /// <param name="selectStatement"></param>
        /// <param name="withClause"></param>
        /// <returns></returns>
        public string GenerateInsertStatement(string table, string[] columns=null, string[] values=null, 
            InsertOrUpdateOption insertOption=InsertOrUpdateOption.NONE, string schemaName="", string selectStatement="", string withClause="") {
            if (columns != null &&
                values != null && 
                columns.Length != values.Length
            ) {
                DebugLogger.LogError("The number of values must equal the number of columns.");
                return default(string);
            }

            if (values != null && 
                !string.IsNullOrEmpty(selectStatement)
            ) {
                DebugLogger.LogWarning("A select statement and values have been passed. The select statement will take priority and the values will be ignored.");
            }

            StringBuilder builder = new StringBuilder();
            string query = "";

            // Optional WITH statement
            if (!string.IsNullOrEmpty(withClause)) {
                builder.Append(withClause);
                builder.Append(" ");
            }

            builder.Append("INSERT ");

            // Handle optional OR selector
            if (insertOption != InsertOrUpdateOption.NONE) {
                builder.Append("OR ");
                builder.Append(insertOption.ToString());
                builder.Append(" ");
            }

            builder.Append("INTO ");
            if (!string.IsNullOrEmpty(schemaName)) builder.Append(schemaName + ".");
            builder.Append(table);

            // Handle optional SELECT statement or VALUES statement (mutually exclusive)
            if (!string.IsNullOrEmpty(selectStatement)) {
                builder.Append(selectStatement);
                builder.Append(";");

                query = builder.ToString();

                return query;
            } else if (string.IsNullOrEmpty(selectStatement) && 
                values != null
            ) {
                /* Handle optional column names if present; if omitted, 
                 * the number of values must match the number of columns 
                 * in the table. */
                if (columns != null && columns.Length > 0) {
                    builder.Append(" (");

                    for (int i = 0; i < columns.Length; i++) {
                        builder.Append(columns[i]);

                        if (i <= columns.Length - 2) builder.Append(",");
                    }

                    builder.Append(") ");
                }

                if (columns == null || columns.Length == 0) builder.Append(" ");
                builder.Append("VALUES ");

                // Handle values
                if (values.Length > 0) {
                    builder.Append("(");

                    for (int i = 0; i < values.Length; i++) {
                        builder.Append(values[i]);

                        if (i <= values.Length - 2) builder.Append(",");
                    }

                    builder.Append(");");
                }

                query = builder.ToString();

                return query;
            }

            // There were no SELECT or VALUES statements, so default to DEFAULT VALUES for the query
            builder.Append(" DEFAULT VALUES;");

            query = builder.ToString();

            return query;
        }
        //ssedlmayr

        /// <summary>
        /// Generates a properly formatted SQL SELECT statement from parameters.
        /// </summary>
        /// <param name="resultColumns"></param>
        /// <param name="tables"></param>
        /// <param name="groupByColumns"></param>
        /// <param name="havingExpression"></param>
        /// <param name="orderByClause"></param>
        /// <param name="limitClause"></param>
        /// <param name="isDistinct"></param>
        /// <param name="whereClause"></param>
        /// <param name="withClause"></param>
        /// <returns></returns>
        public string GenerateSelectStatement(string[] resultColumns=null, string[] tables=null,
            string[] groupByColumns=null, string havingExpression="", string orderByClause="", string limitClause="", 
            bool isDistinct=false, string whereClause="", string withClause="") {
            StringBuilder builder = new StringBuilder();

            // Optional WITH statement
            if (!string.IsNullOrEmpty(withClause)) {
                builder.Append(withClause);
                builder.Append(" ");
            }

            builder.Append("SELECT ");
            if (isDistinct) builder.Append("DISTINCT "); // Handle optional DISTINCT selector

            /* Handle optional result columns, if specified; if not, 
             * default to '*' */
            if (resultColumns != null &&
                resultColumns.Length > 0
            ) {
                for (int i = 0; i < resultColumns.Length; i++) {
                    builder.Append(resultColumns[i]);

                    if (i <= resultColumns.Length - 2) builder.Append(",");
                }

                builder.Append(" ");
            } else {
                builder.Append("*");
            }

            builder.Append("FROM ");

            /* Handle optional tables, if specified; if not, 
             * default to '*' */
            if (tables != null &&
                tables.Length > 0
            ) {
                for (int i = 0; i < tables.Length; i++) {
                    builder.Append(tables[i]);

                    if (i <= tables.Length - 2) builder.Append(",");
                }
            } else {
                builder.Append("*");
            }

            // Optional WHERE clause
            if (!string.IsNullOrEmpty(whereClause)) {
                builder.Append(" ");
                builder.Append(whereClause);
            }

            // Optional GROUP BY, HAVING clause
            if (groupByColumns != null &&
                groupByColumns.Length > 0
            ) {
                builder.Append(" GROUP BY ");

                for (int i = 0; i < groupByColumns.Length; i++) {
                    builder.Append(groupByColumns[i]);

                    if (i <= groupByColumns.Length - 2) builder.Append(",");
                }

                // Optional HAVING clause
                if (!string.IsNullOrEmpty(havingExpression)) {
                    builder.Append(" HAVING ");
                    builder.Append(havingExpression);
                } 
            }

            // Optional ORDER BY clause
            if (!string.IsNullOrEmpty(orderByClause)) {
                builder.Append(" ");
                builder.Append(orderByClause);
            }

            // Optional LIMIT, OFFSET clause
            if (!string.IsNullOrEmpty(limitClause)) {
                builder.Append(" ");
                builder.Append(limitClause);
            }

            string query = builder.ToString();

            return query;
        }
        //ssedlmayr

        /// <summary>
        /// Generates a properly formatted SQL UPDATE statement from parameters.
        /// </summary>
        /// <param name="table"></param>
        /// <param name="schemaName"></param>
        /// <param name="updateOption"></param>
        /// <param name="setValues"></param>
        /// <param name="orderByClause"></param>
        /// <param name="limitClause"></param>
        /// <param name="whereClause"></param>
        /// <param name="withClause"></param>
        /// <returns></returns>
        public string GenerateUpdateStatement(string table, KeyValuePair<string, string>[] setValues, string schemaName="", 
            InsertOrUpdateOption updateOption=InsertOrUpdateOption.NONE, string orderByClause="", string limitClause="", string whereClause="", string withClause="") {
            if (setValues == null ||
                setValues.Length == 0
            ) {
                DebugLogger.LogError("SET columns and values were not defined.");
                return default(string);
            }

            StringBuilder builder = new StringBuilder();

            if (!string.IsNullOrEmpty(withClause)) builder.Append(withClause);
            builder.Append("UPDATE ");

            // Handle optional OR selector
            if (updateOption != InsertOrUpdateOption.NONE) {
                builder.Append("OR ");
                builder.Append(updateOption.ToString());
                builder.Append(" ");
            }

            if (!string.IsNullOrEmpty(schemaName)) builder.Append(schemaName + ".");
            builder.Append(table);

            // Handle SET statement
            builder.Append(" SET ");

            for (int i = 0; i < setValues.Length; i++) {
                builder.Append(setValues[i].Key);
                builder.Append(" = ");
                builder.Append(setValues[i].Value);

                if (i <= setValues.Length - 2) builder.Append(",");
            }

            // Optional WHERE clause
            if (!string.IsNullOrEmpty(whereClause)) {
                builder.Append(" ");
                builder.Append(whereClause);
            }

            // Optional ORDER BY clause
            if (!string.IsNullOrEmpty(orderByClause)) {
                builder.Append(" ");
                builder.Append(orderByClause);
            }

            // Optional LIMIT, OFFSET clause
            if (!string.IsNullOrEmpty(limitClause)) {
                builder.Append(" ");
                builder.Append(limitClause);
            }

            string query = builder.ToString();

            return query;
        }
        //ssedlmayr

        #region Sub-statement generation methods

        //
        [ToDo("Implement", true, int.MinValue)]
        public string GenerateCompoundSelectStatement(string[] selectStatements, string withClause="") { return default(string); }
        //ssedlmayr

        //
        [ToDo("Implement", true, int.MinValue)]
        public string GenerateSelectWithStatement() { return default(string); }
        //ssedlmayr

        //
        [ToDo("Implement", true, int.MinValue)]
        public string GenerateUpdateWithStatement() { return default(string); }
        //ssedlmayr

        /// <summary>
        /// Generates a properly formatted compound SQL ORDER BY statement from parameters.
        /// </summary>
        /// <param name="orderByColumns"></param>
        /// <param name="orderByPrecedence"></param>
        /// <returns></returns>
        public string GenerateOrderByStatement(string[] orderByColumns, OrderByPrecedence orderByPrecedence=OrderByPrecedence.NONE) {
            StringBuilder builder = new StringBuilder();

            if (orderByColumns != null &&
                orderByColumns.Length > 0
            ) {
                builder.Append("ORDER BY ");

                for (int i = 0; i < orderByColumns.Length; i++) {
                    builder.Append(orderByColumns[i]);

                    if (i <= orderByColumns.Length - 2) builder.Append(",");
                }

                if (orderByPrecedence != OrderByPrecedence.NONE) {
                    builder.Append(" ");
                    builder.Append(orderByPrecedence.ToString());
                }
            }

            string statement = builder.ToString();

            return statement;
        }
        //ssedlmayr

        /// <summary>
        /// Generates a properly formatted compound SQL LIMIT, OFFSET statement from parameters.
        /// </summary>
        /// <param name="limits"></param>
        /// <param name="offset"></param>
        /// <returns></returns>
        public string GenerateLimitStatement(int[] limits=null, int offset=-1) {
            StringBuilder builder = new StringBuilder();

            if (limits != null &&
                limits.Length > 0
            ) {
                builder.Append("LIMIT ");

                for (int i = 0; i < limits.Length; i++) {
                    builder.Append(limits[i].ToString());

                    if (i <= limits.Length - 2) builder.Append(",");
                }

                if (offset > 0) {
                    builder.Append(" OFFSET ");
                    builder.Append(offset.ToString());
                }
            }

            string statement = builder.ToString();

            return statement;
        }
        //ssedlmayr

        /// <summary>
        /// Generates a properly formatted SQL WHERE statement for use in another statement in the form of: 
        /// WHERE [leftSide1,...,leftSideN] = [rightSide1,...,rightSideN].
        /// </summary>
        /// <param name="leftSide"></param>
        /// <param name="rightSide"></param>
        /// <returns></returns>
        public string GenerateWhereStatement(string[] leftSide, string[] rightSide) {
            if (leftSide == null || rightSide == null) {
                DebugLogger.LogError("Both the leftSide and rightSide collections must be non-null.");
                return default(string);
            }

            if (leftSide.Length != rightSide.Length) {
                DebugLogger.LogError("The leftSide and rightSide collections must have equal length.");
                return default(string);
            }

            StringBuilder builder = new StringBuilder();
            string expression = "";

            for (int i = 0; i < leftSide.Length; i++) {
                if (string.IsNullOrEmpty(leftSide[i]) ||
                    string.IsNullOrEmpty(rightSide[i])
                ) {
                    DebugLogger.LogError("The leftSide and rightSide collections must not contain null values.");
                    return default(string);
                }

                builder.Append(leftSide[i]);
                builder.Append(" = ");
                builder.Append(rightSide[i]);

                if (i <= leftSide.Length - 2) builder.Append(", ");
            }

            expression = builder.ToString();

            return GenerateWhereStatement(expression);
        }
        //ssedlmayr

        /// <summary>
        /// Generates a properly formatted SQL WHERE statement for use in another statement in the form of: 
        /// WHERE [leftSide] = [rightSide].
        /// </summary>
        /// <param name="leftSide"></param>
        /// <param name="rightSide"></param>
        /// <returns></returns>
        public string GenerateWhereStatement(string leftSide, string rightSide) {
            if (string.IsNullOrEmpty(leftSide) ||
                string.IsNullOrEmpty(rightSide)
            ){
                DebugLogger.LogError("The leftSide and rightSide expressions must not contain null values.");
                return default(string);
            }

            StringBuilder builder = new StringBuilder();
            string expression = "";

            builder.Append(leftSide);
            builder.Append(" = ");
            builder.Append(rightSide);

            expression = builder.ToString();

            return GenerateWhereStatement(expression);
        }
        //ssedlmayr

        /// <summary>
        /// Generates a properly formatted SQL WHERE statement for use in another statement from the provided expression.
        /// </summary>
        /// <param name="expression"></param>
        /// <returns></returns>
        public string GenerateWhereStatement(string expression) {
            StringBuilder builder = new StringBuilder();
            string query = "";

            builder.Append("WHERE ");
            builder.Append(expression);

            query = builder.ToString();

            return query;
        }
        //ssedlmayr

        #endregion

        #endregion

        #region Unformatted query methods

        /// <summary>
        /// Executes a query that doesn't require a response, such as Update, Delete, et cetera.
        /// </summary>
        /// <param name='query'></param>
        /// <exception cref='dk.IO.Sqlite.SqliteException'>
        /// Thrown when a sqlite exception occurs during execution.
        /// </exception>
        public void Query(string query) {
            if (!_canExecuteQuery) {
                DebugLogger.LogError("Can't execute the query, verify DB origin file");

                return;
            }

            this.Open();

            if (!_isConnectionOpen) throw new SqliteException("SQLite database is not open.");

            IntPtr stmHandle = Prepare(query);

            if (SqliteStep(stmHandle) != SQLITE_DONE) throw new SqliteException("Could not execute SQL statement.");

            Finalize(stmHandle);
            this.Close();
        }
        //Busta117 -> ssedlmayr (renamed from ExecuteNonQuery)

        /// <summary>
        /// Executes a query that requires a response (SELECT, etc).
        /// </summary>
        /// <returns>
        /// a Dictionary with the response data.
        /// </returns>
        /// <param name='query'></param>
        /// <exception cref='dk.IO.Sqlite.SqliteException'>
        /// Thrown when a sqlite exception occurs during execution.
        /// </exception>
        public Table QueryWithResponse(string query) {
            if (!_canExecuteQuery) {
                DebugLogger.LogError("Can't execute the query, verify the DB origin file.");
                return null;
            }

            this.Open();

            if (!_isConnectionOpen) {
                throw new SqliteException("SQLite database is not open.");
            }

            IntPtr stmHandle = Prepare(query);
            int columnCount = SqliteColumnCount(stmHandle);
            var dataTable = new Table();

            for (int i = 0; i < columnCount; i++) {
                string columnName = Marshal.PtrToStringAnsi(SqliteColumnName(stmHandle, i));
                dataTable.Columns.Add(columnName);
            }


            // Populate table
            while (SqliteStep(stmHandle) == SQLITE_ROW) {
                object[] row = new object[columnCount];

                for (int i = 0; i < columnCount; i++) {
                    switch (SqliteColumnType(stmHandle, i)) {
                        case SQLITE_INTEGER:
                            row[i] = SqliteColumnInt(stmHandle, i);
                            break;

                        case SQLITE_TEXT:
                            IntPtr text = SqliteColumnText(stmHandle, i);
                            row[i] = Marshal.PtrToStringAnsi(text);
                            break;

                        case SQLITE_FLOAT:
                            row[i] = SqliteColumnDouble(stmHandle, i);
                            break;

                        case SQLITE_BLOB:
                            IntPtr blob = SqliteColumnBlob(stmHandle, i);
                            int size = SqliteColumnBytes(stmHandle, i);
                            byte[] data = new byte[size];
                            Marshal.Copy(blob, data, 0, size);
                            row[i] = data;
                            break;

                        case SQLITE_NULL:
                            row[i] = null;
                            break;
                    }
                }

                dataTable.AddRow(row);
            }

            Finalize(stmHandle);
            this.Close();

            return dataTable;
        }
        //Busta117 -> ssedlmayr (renamed from ExecuteQuery)

        /// <summary>
        /// Attempts to execute a fully formatted SQL statement provided in string form. 
        /// </summary>
        /// <param name="script"></param>
        public void ExecuteScript(string script) {
            string[] statements = script.Split(';');

            foreach (string statement in statements) {
                if (!string.IsNullOrEmpty(statement.Trim())) {
                    Query(statement);
                }
            }
        }
        //Busta117

        #endregion

        #region Private helper methods

        /// <summary>
        /// Opens the database for reading and writing.
        /// </summary>
        protected void Open() {
            this.Open(_databasePath);
        }
        //Busta117

        /// <summary>
        /// Opens the database for reading and writing.
        /// </summary>
        /// <param name="path"></param>
        protected void Open(string path) {
            if (_isConnectionOpen) throw new SqliteException("There is already an open connection");

            if (SqliteOpen(path, out _connection) != SQLITE_OK) throw new SqliteException("Could not open database file: " + path);

            _isConnectionOpen = true;
        }
        //Busta117

        /// <summary>
        /// Closes the database for reading and writing.
        /// </summary>
        protected void Close() {
            if (_isConnectionOpen) SqliteClose(_connection);

            _isConnectionOpen = false;
        }
        //Busta117

        /// <summary>
        /// Compiles a SQL query in string form into byte code to execute in the database.
        /// </summary>
        /// <param name="query"></param>
        /// <returns></returns>
        protected IntPtr Prepare(string query) {
            IntPtr stmHandle;

            if (SqlitePrepareV2(_connection, query, query.Length, out stmHandle, IntPtr.Zero) != SQLITE_OK) {
                IntPtr errorMsg = SqliteErrorMessage(_connection);
                throw new SqliteException(Marshal.PtrToStringAnsi(errorMsg));
            }

            return stmHandle;
        }
        //Busta117

        /// <summary>
        /// Deletes a SQL statement that has been compiled to byte code for execution with Prepare().
        /// </summary>
        /// <param name="stmHandle"></param>
        protected void Finalize(IntPtr stmHandle) {
            if (SqliteFinalize(stmHandle) != SQLITE_OK) {
                throw new SqliteException("Could not finalize SQL statement.");
            }
        }
        //Busta117

        #endregion
    }

    class CoroutineCaller : MonoBehaviour {}
    //ssedlmayr
}
